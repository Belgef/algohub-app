//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class CommentClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7224";

    }

    getLessonComments(lessonId: number | undefined , cancelToken?: CancelToken | undefined): Promise<LessonCommentViewModel[]> {
        let url_ = this.baseUrl + "/LessonComments?";
        if (lessonId === null)
            throw new Error("The parameter 'lessonId' cannot be null.");
        else if (lessonId !== undefined)
            url_ += "lessonId=" + encodeURIComponent("" + lessonId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLessonComments(_response);
        });
    }

    protected processGetLessonComments(response: AxiosResponse): Promise<LessonCommentViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = _responseText;
            return Promise.resolve<LessonCommentViewModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LessonCommentViewModel[]>(null as any);
    }

    addLessonComment(comment: CommentCreateViewModel, cancelToken?: CancelToken | undefined): Promise<number | null> {
        let url_ = this.baseUrl + "/LessonComments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (comment.rootId === null || comment.rootId === undefined)
            throw new Error("The parameter 'lessonId' cannot be null.");
        else
            content_.append("LessonId", comment.rootId.toString());
        if (comment.parentCommentId !== null && comment.parentCommentId !== undefined)
            content_.append("ParentCommentId", comment.parentCommentId.toString());
        if (comment.content !== null && comment.content !== undefined)
            content_.append("Content", comment.content.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddLessonComment(_response);
        });
    }

    protected processAddLessonComment(response: AxiosResponse): Promise<number | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = _responseText;
            return Promise.resolve<number | null>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number | null>(null as any);
    }

    getProblemComments(problemId: number | undefined , cancelToken?: CancelToken | undefined): Promise<ProblemCommentViewModel[]> {
        let url_ = this.baseUrl + "/ProblemComments?";
        if (problemId === null)
            throw new Error("The parameter 'problemId' cannot be null.");
        else if (problemId !== undefined)
            url_ += "problemId=" + encodeURIComponent("" + problemId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProblemComments(_response);
        });
    }

    protected processGetProblemComments(response: AxiosResponse): Promise<ProblemCommentViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = _responseText;
            return Promise.resolve<ProblemCommentViewModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProblemCommentViewModel[]>(null as any);
    }

    addProblemComment(comment: CommentCreateViewModel, cancelToken?: CancelToken | undefined): Promise<number | null> {
        let url_ = this.baseUrl + "/ProblemComments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (comment.rootId === null || comment.rootId === undefined)
            throw new Error("The parameter 'problemId' cannot be null.");
        else
            content_.append("ProblemId", comment.rootId.toString());
        if (comment.parentCommentId !== null && comment.parentCommentId !== undefined)
            content_.append("ParentCommentId", comment.parentCommentId.toString());
        if (comment.content !== null && comment.content !== undefined)
            content_.append("Content", comment.content.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddProblemComment(_response);
        });
    }

    protected processAddProblemComment(response: AxiosResponse): Promise<number | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = _responseText;
            return Promise.resolve<number | null>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number | null>(null as any);
    }

    getSolveComments(solveId: number | undefined , cancelToken?: CancelToken | undefined): Promise<SolveCommentViewModel[]> {
        let url_ = this.baseUrl + "/SolveComments?";
        if (solveId === null)
            throw new Error("The parameter 'solveId' cannot be null.");
        else if (solveId !== undefined)
            url_ += "solveId=" + encodeURIComponent("" + solveId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSolveComments(_response);
        });
    }

    protected processGetSolveComments(response: AxiosResponse): Promise<SolveCommentViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = _responseText;
            return Promise.resolve<SolveCommentViewModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SolveCommentViewModel[]>(null as any);
    }

    addSolveComment(comment: CommentCreateViewModel, cancelToken?: CancelToken | undefined): Promise<number | null> {
        let url_ = this.baseUrl + "/SolveComments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (comment.rootId === null || comment.rootId === undefined)
            throw new Error("The parameter 'solveId' cannot be null.");
        else
            content_.append("SolveId", comment.rootId.toString());
        if (comment.parentCommentId !== null && comment.parentCommentId !== undefined)
            content_.append("ParentCommentId", comment.parentCommentId.toString());
        if (comment.content !== null && comment.content !== undefined)
            content_.append("Content", comment.content.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddSolveComment(_response);
        });
    }

    protected processAddSolveComment(response: AxiosResponse): Promise<number | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = _responseText;
            return Promise.resolve<number | null>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number | null>(null as any);
    }
}

export class LessonClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7224";

    }

    getAll(  cancelToken?: CancelToken | undefined): Promise<LessonViewModel[]> {
        let url_ = this.baseUrl + "/Lesson";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<LessonViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = _responseText;
            return Promise.resolve<LessonViewModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LessonViewModel[]>(null as any);
    }

    addLesson(lesson: LessonCreateViewModel , cancelToken?: CancelToken | undefined): Promise<number | null> {
        let url_ = this.baseUrl + "/Lesson";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (lesson.title !== null && lesson.title !== undefined)
            content_.append("Title", lesson.title.toString());
        if (lesson.lessonContent !== null && lesson.lessonContent !== undefined)
            content_.append("LessonContent", lesson.lessonContent.toString());
        if (lesson.image !== null && lesson.image !== undefined)
            content_.append("Image", lesson.image);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddLesson(_response);
        });
    }

    protected processAddLesson(response: AxiosResponse): Promise<number | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = _responseText;
            return Promise.resolve<number | null>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number | null>(null as any);
    }

    get(problemId: number , cancelToken?: CancelToken | undefined): Promise<LessonViewModel> {
        let url_ = this.baseUrl + "/Lesson/{problemId}";
        if (problemId === undefined || problemId === null)
            throw new Error("The parameter 'problemId' must be defined.");
        url_ = url_.replace("{problemId}", encodeURIComponent("" + problemId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<LessonViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = _responseText;
            return Promise.resolve<LessonViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LessonViewModel>(null as any);
    }

    addLessonVote(id: number | undefined, isUpvote: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<number | null> {
        let url_ = this.baseUrl + "/Lesson/Vote";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (isUpvote === null || isUpvote === undefined)
            throw new Error("The parameter 'isUpvote' cannot be null.");
        else
            content_.append("IsUpvote", isUpvote.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddLessonVote(_response);
        });
    }

    protected processAddLessonVote(response: AxiosResponse): Promise<number | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = _responseText;
            return Promise.resolve<number | null>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number | null>(null as any);
    }

    getLessonVote(lessonId: number | undefined , cancelToken?: CancelToken | undefined): Promise<boolean | null> {
        let url_ = this.baseUrl + "/Lesson/Vote?";
        if (lessonId === null)
            throw new Error("The parameter 'lessonId' cannot be null.");
        else if (lessonId !== undefined)
            url_ += "lessonId=" + encodeURIComponent("" + lessonId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLessonVote(_response);
        });
    }

    protected processGetLessonVote(response: AxiosResponse): Promise<boolean | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = _responseText;
            return Promise.resolve<boolean | null>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean | null>(null as any);
    }
}

export class ProblemClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7224";

    }

    getAll(  cancelToken?: CancelToken | undefined): Promise<ProblemViewModel[]> {
        let url_ = this.baseUrl + "/Problem";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ProblemViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = _responseText;
            return Promise.resolve<ProblemViewModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProblemViewModel[]>(null as any);
    }

    addProblem(problem: ProblemCreateViewModel, cancelToken?: CancelToken | undefined): Promise<number | null> {
        let url_ = this.baseUrl + "/Problem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (problem.problemName !== null && problem.problemName !== undefined)
            content_.append("ProblemName", problem.problemName.toString());
        if (problem.problemContent !== null && problem.problemContent !== undefined)
            content_.append("ProblemContent", problem.problemContent.toString());
        if (problem.image !== null && problem.image !== undefined)
            content_.append("Image", problem.image);
        if (problem.timeLimitMs === null || problem.timeLimitMs === undefined)
            throw new Error("The parameter 'timeLimitMs' cannot be null.");
        else
            content_.append("TimeLimitMs", problem.timeLimitMs.toString());
        if (problem.memoryLimitBytes === null || problem.memoryLimitBytes === undefined)
            throw new Error("The parameter 'memoryLimitBytes' cannot be null.");
        else
            content_.append("MemoryLimitBytes", problem.memoryLimitBytes.toString());
        if (problem.testsString !== null && problem.testsString !== undefined)
            content_.append("TestsString", problem.testsString.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddProblem(_response);
        });
    }

    protected processAddProblem(response: AxiosResponse): Promise<number | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = _responseText;
            return Promise.resolve<number | null>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number | null>(null as any);
    }

    get(problemId: number , cancelToken?: CancelToken | undefined): Promise<ProblemViewModel> {
        let url_ = this.baseUrl + "/Problem/{problemId}";
        if (problemId === undefined || problemId === null)
            throw new Error("The parameter 'problemId' must be defined.");
        url_ = url_.replace("{problemId}", encodeURIComponent("" + problemId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ProblemViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = _responseText;
            return Promise.resolve<ProblemViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProblemViewModel>(null as any);
    }

    addProblemVote(id: number | undefined, isUpvote: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<number | null> {
        let url_ = this.baseUrl + "/Problem/Vote";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (isUpvote === null || isUpvote === undefined)
            throw new Error("The parameter 'isUpvote' cannot be null.");
        else
            content_.append("IsUpvote", isUpvote.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddProblemVote(_response);
        });
    }

    protected processAddProblemVote(response: AxiosResponse): Promise<number | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = _responseText;
            return Promise.resolve<number | null>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number | null>(null as any);
    }

    getProblemVote(problemId: number | undefined , cancelToken?: CancelToken | undefined): Promise<boolean | null> {
        let url_ = this.baseUrl + "/Problem/Vote?";
        if (problemId === null)
            throw new Error("The parameter 'problemId' cannot be null.");
        else if (problemId !== undefined)
            url_ += "problemId=" + encodeURIComponent("" + problemId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProblemVote(_response);
        });
    }

    protected processGetProblemVote(response: AxiosResponse): Promise<boolean | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = _responseText;
            return Promise.resolve<boolean | null>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean | null>(null as any);
    }
}

export class StoreClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7224";

    }

    uploadImage(image: File | null | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/Store";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (image !== null && image !== undefined)
            content_.append("Image", image);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUploadImage(_response);
        });
    }

    protected processUploadImage(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = _responseText;
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }
}

export class UserClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7224";

    }

    register(user: UserCreateViewModel, cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (user.userName !== null && user.userName !== undefined)
            content_.append("UserName", user.userName.toString());
        if (user.fullName !== null && user.fullName !== undefined)
            content_.append("FullName", user.fullName.toString());
        if (user.email !== null && user.email !== undefined)
            content_.append("Email", user.email.toString());
        if (user.password !== null && user.password !== undefined)
            content_.append("Password", user.password.toString());
        if (user.icon !== null && user.icon !== undefined)
            content_.append("Icon", user.icon);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = _responseText;
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    login(user: UserLoginViewModel , cancelToken?: CancelToken | undefined): Promise<UserTokenData> {
        let url_ = this.baseUrl + "/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: AxiosResponse): Promise<UserTokenData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = _responseText;
            return Promise.resolve<UserTokenData>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserTokenData>(null as any);
    }

    refreshToken(tokens: UserRefreshTokenViewModel , cancelToken?: CancelToken | undefined): Promise<UserTokenData> {
        let url_ = this.baseUrl + "/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tokens);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRefreshToken(_response);
        });
    }

    protected processRefreshToken(response: AxiosResponse): Promise<UserTokenData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = _responseText;
            return Promise.resolve<UserTokenData>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserTokenData>(null as any);
    }

    getUserById(userId: string | undefined , cancelToken?: CancelToken | undefined): Promise<UserViewModel> {
        let url_ = this.baseUrl + "/User?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUserById(_response);
        });
    }

    protected processGetUserById(response: AxiosResponse): Promise<UserViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = _responseText;
            return Promise.resolve<UserViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserViewModel>(null as any);
    }

    checkUserName(userName: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/checkUserName?";
        if (userName !== undefined && userName !== null)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckUserName(_response);
        });
    }

    protected processCheckUserName(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = _responseText;
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    checkEmail(email: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/checkEmail?";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckEmail(_response);
        });
    }

    protected processCheckEmail(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = _responseText;
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export interface LessonCommentViewModel {
    lessonCommentId?: number | undefined;
    lessonId?: number | undefined;
    author?: UserViewModel | undefined;
    content?: string | undefined;
    createDate?: Date | undefined;
    replies?: LessonCommentViewModel[] | undefined;
}

export interface UserViewModel {
    userId: string;
    userName: string;
    fullName?: string | undefined;
    email: string;
    role?: string | undefined;
    iconName?: string | undefined;
}

export interface ProblemCommentViewModel {
    problemCommentId?: number | undefined;
    problemId?: number | undefined;
    author?: UserViewModel | undefined;
    content?: string | undefined;
    createDate?: Date | undefined;
    replies?: ProblemCommentViewModel[] | undefined;
}

export interface SolveCommentViewModel {
    solveCommentId?: number | undefined;
    solveId?: number | undefined;
    author?: UserViewModel | undefined;
    content?: string | undefined;
    createDate?: Date | undefined;
    replies?: SolveCommentViewModel[] | undefined;
}

export interface CommentCreateViewModel {
    rootId: number | undefined;
    parentCommentId: number | null | undefined;
    content: string | null | undefined;
}

export interface CommentViewModel {
    id?: number | undefined;
    rootId?: number | undefined;
    author?: UserViewModel | undefined;
    content?: string | undefined;
    createDate?: Date | undefined;
    replies?: CommentViewModel[] | undefined;
}

export interface LessonViewModel {
    lessonId: number;
    title: string;
    lessonContent: ContentElement[];
    author?: UserViewModel | undefined;
    imageName?: string | undefined;
    views: number;
    upvotes: number;
    downvotes: number;
    createDate: Date;
}

export interface ProblemViewModel {
    problemId: number;
    problemName: string;
    problemContent: ContentElement[];
    author?: UserViewModel | undefined;
    imageName?: string | undefined;
    views: number;
    solves: number;
    upvotes: number;
    downvotes: number;
    timeLimitMs: number;
    memoryLimitBytes: number;
    createDate: Date;
}

export interface UserViewModel {
    userId: string;
    userName: string;
    fullName?: string | undefined;
    email: string;
    role?: string | undefined;
    iconName?: string | undefined;
}

export interface ContentCreateElement {
    contentType: ContentType;
    value?: string | undefined;
    image?: File | undefined;
    code?: string | undefined;
}

export interface ContentElement {
    contentType: ContentType;
    value?: string | undefined;
    imageName?: string | undefined;
    code?: string | undefined;
}

export enum ContentType {
    Subtitle = 0,
    Emphasis = 1,
    Paragraph = 2,
    Image = 3,
    Bar = 4,
    Code = 5,
}

export interface UserCreateViewModel {
    userName: string;
    fullName?: string;
    email: string;
    icon?: File;
    password: string;
    confirmPassword: string;
}

export interface UserTokenData {
    token: string;
    refreshToken: string;
}

export interface UserLoginViewModel {
    userName: string;
    password: string;
}

export interface UserRefreshTokenViewModel {
    refreshToken: string;
    oldJwtToken: string;
}

export interface ProblemCreateViewModel {
    problemName: string | null | undefined;
    problemContent: string | null | undefined;
    image: File | null | undefined;
    timeLimitMs: number | undefined;
    memoryLimitBytes: number | undefined;
    testsString: string | null | undefined;
}

export interface LessonCreateViewModel {
    title: string | null | undefined;
    lessonContent: string | null | undefined;
    image: File | null | undefined;
}

export interface TestViewModel {
    input: string | undefined,
    output: string | undefined
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}
